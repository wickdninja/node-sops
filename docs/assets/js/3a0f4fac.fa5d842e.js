"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[31],{7208:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>a,contentTitle:()=>c,default:()=>p,frontMatter:()=>o,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"api/ts","title":"TypeScript API","description":"This page documents the complete API for using Node SOPS in a TypeScript project, including all type definitions.","source":"@site/src/docs/api/ts.md","sourceDirName":"api","slug":"/api/ts","permalink":"/node-sops/api/ts","draft":false,"unlisted":false,"editUrl":"https://github.com/wickdninja/node-sops/edit/main/docs-src/src/docs/src/docs/api/ts.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3,"title":"TypeScript API"},"sidebar":"tutorialSidebar","previous":{"title":"JavaScript API","permalink":"/node-sops/api/js"}}');var i=t(4848),r=t(8453);const o={sidebar_position:3,title:"TypeScript API"},c="TypeScript API Reference",a={},l=[{value:"Installation",id:"installation",level:2},{value:"Basic Usage",id:"basic-usage",level:2},{value:"API Reference",id:"api-reference",level:2},{value:"Type Definitions",id:"type-definitions",level:3},{value:"Class: Sops",id:"class-sops",level:3},{value:"Constructor",id:"constructor",level:4},{value:"Method: initialize",id:"method-initialize",level:4},{value:"Method: encrypt",id:"method-encrypt",level:4},{value:"Method: decrypt",id:"method-decrypt",level:4},{value:"Method: view",id:"method-view",level:4},{value:"Method: get",id:"method-get",level:4},{value:"Method: rotate",id:"method-rotate",level:4},{value:"Method: encryptContent",id:"method-encryptcontent",level:4},{value:"Method: decryptContent",id:"method-decryptcontent",level:4},{value:"Error Handling with TypeScript",id:"error-handling-with-typescript",level:2},{value:"Advanced Type Examples",id:"advanced-type-examples",level:2},{value:"Strong Typing for Nested Secrets",id:"strong-typing-for-nested-secrets",level:3},{value:"Creating Type-Safe APIs with Node SOPS",id:"creating-type-safe-apis-with-node-sops",level:3}];function d(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...n.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(e.header,{children:(0,i.jsx)(e.h1,{id:"typescript-api-reference",children:"TypeScript API Reference"})}),"\n",(0,i.jsx)(e.p,{children:"This page documents the complete API for using Node SOPS in a TypeScript project, including all type definitions."}),"\n",(0,i.jsx)(e.h2,{id:"installation",children:"Installation"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-bash",children:"npm install node-sops\n"})}),"\n",(0,i.jsxs)(e.p,{children:["Node SOPS includes TypeScript type definitions out of the box, so there's no need to install separate ",(0,i.jsx)(e.code,{children:"@types"})," packages."]}),"\n",(0,i.jsx)(e.h2,{id:"basic-usage",children:"Basic Usage"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-typescript",children:"import { Sops } from 'node-sops';\n\n// Create a new instance\nconst sops = new Sops();\n\n// Initialize a new key (if not already created)\ntry {\n  sops.initialize();\n} catch (error) {\n  // Key already exists\n}\n\n// Encrypt a file\nsops.encrypt('secrets.yaml', 'secrets.enc.json');\n\n// Decrypt a file\nsops.decrypt('secrets.enc.json', 'secrets.yaml');\n\n// Define your secrets structure type\ninterface Secrets {\n  data: {\n    api: {\n      key: string;\n      secret: string;\n    };\n    database: {\n      username: string;\n      password: string;\n    };\n  };\n}\n\n// View decrypted content with type safety\nconst secrets = sops.view<Secrets>('secrets.enc.json');\nconsole.log(secrets.data.api.key); // TypeScript knows this is a string\n\n// Get a specific value\nconst apiKey = sops.get('secrets.enc.json', 'data.api.key');\nconsole.log(apiKey);\n"})}),"\n",(0,i.jsx)(e.h2,{id:"api-reference",children:"API Reference"}),"\n",(0,i.jsx)(e.h3,{id:"type-definitions",children:"Type Definitions"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-typescript",children:"/**\n * Options for constructing a Sops instance\n */\ninterface SopsOptions {\n  /**\n   * Path to the encryption key file\n   * @default '.sops-key'\n   */\n  keyPath?: string;\n}\n\n/**\n * Options for initializing a new encryption key\n */\ninterface InitOptions {\n  /**\n   * Overwrite existing key if present\n   * @default false\n   */\n  force?: boolean;\n  \n  /**\n   * Override the instance's keyPath for this operation\n   */\n  keyPath?: string;\n}\n\n/**\n * Common options for operations\n */\ninterface OperationOptions {\n  /**\n   * Override the instance's keyPath for this operation\n   */\n  keyPath?: string;\n}\n\n/**\n * Options for decryption operations\n */\ninterface DecryptOptions extends OperationOptions {\n  /**\n   * Force output format\n   * @default Inferred from output file extension\n   */\n  format?: 'yaml' | 'json';\n}\n\n/**\n * Structure of encrypted content\n */\ninterface EncryptedContent {\n  /**\n   * Base64-encoded initialization vector\n   */\n  iv: string;\n  \n  /**\n   * Base64-encoded encrypted content\n   */\n  content: string;\n  \n  /**\n   * Metadata about the encryption\n   */\n  metadata: {\n    /**\n     * ISO date string of when the content was encrypted\n     */\n    encryptedAt: string;\n    \n    /**\n     * Schema version\n     */\n    version: string;\n  };\n}\n"})}),"\n",(0,i.jsx)(e.h3,{id:"class-sops",children:"Class: Sops"}),"\n",(0,i.jsx)(e.p,{children:"The main class for interacting with Node SOPS functionality."}),"\n",(0,i.jsx)(e.h4,{id:"constructor",children:"Constructor"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-typescript",children:"class Sops {\n  constructor(options?: SopsOptions);\n}\n"})}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Parameters:"})}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:"options"})," (SopsOptions, optional): Configuration options","\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:"keyPath"})," (string, optional): Path to the encryption key file. Default: ",(0,i.jsx)(e.code,{children:".sops-key"})]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Example:"})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-typescript",children:"// Using default key path\nconst defaultSops = new Sops();\n\n// Using custom key path\nconst customSops = new Sops({\n  keyPath: './config/custom-key'\n});\n"})}),"\n",(0,i.jsx)(e.h4,{id:"method-initialize",children:"Method: initialize"}),"\n",(0,i.jsx)(e.p,{children:"Initializes a new encryption key."}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-typescript",children:"initialize(options?: InitOptions): string;\n"})}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Parameters:"})}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:"options"})," (InitOptions, optional): Initialization options","\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:"force"})," (boolean, optional): Overwrite existing key if present. Default: ",(0,i.jsx)(e.code,{children:"false"})]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:"keyPath"})," (string, optional): Override the instance's keyPath for this operation"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Returns:"})}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"(string): The generated encryption key"}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Throws:"})}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:["Error if key already exists and ",(0,i.jsx)(e.code,{children:"force"})," is not ",(0,i.jsx)(e.code,{children:"true"})]}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Example:"})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-typescript",children:"try {\n  const key = sops.initialize();\n  console.log('New key created:', key);\n} catch (error) {\n  console.error('Key already exists');\n}\n\n// Force create a new key\nconst newKey = sops.initialize({ force: true });\n"})}),"\n",(0,i.jsx)(e.h4,{id:"method-encrypt",children:"Method: encrypt"}),"\n",(0,i.jsx)(e.p,{children:"Encrypts a plaintext file containing secrets."}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-typescript",children:"encrypt(inputPath: string, outputPath: string, options?: OperationOptions): void;\n"})}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Parameters:"})}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:"inputPath"})," (string): Path to the input file (YAML or JSON)"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:"outputPath"})," (string): Path where the encrypted file will be written"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:"options"})," (OperationOptions, optional): Encryption options","\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:"keyPath"})," (string, optional): Override the instance's keyPath for this operation"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Throws:"})}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Error if input file cannot be read or output file cannot be written"}),"\n",(0,i.jsx)(e.li,{children:"Error if encryption fails"}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Example:"})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-typescript",children:"// Basic usage\nsops.encrypt('secrets.yaml', 'secrets.enc.json');\n\n// With custom key path for this operation\nsops.encrypt('secrets.yaml', 'secrets.enc.json', {\n  keyPath: './special-project-key'\n});\n"})}),"\n",(0,i.jsx)(e.h4,{id:"method-decrypt",children:"Method: decrypt"}),"\n",(0,i.jsx)(e.p,{children:"Decrypts an encrypted file to its original plaintext form."}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-typescript",children:"decrypt(inputPath: string, outputPath: string, options?: DecryptOptions): void;\n"})}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Parameters:"})}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:"inputPath"})," (string): Path to the encrypted file"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:"outputPath"})," (string): Path where the decrypted file will be written"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:"options"})," (DecryptOptions, optional): Decryption options","\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:"keyPath"})," (string, optional): Override the instance's keyPath for this operation"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:"format"})," ('yaml' | 'json', optional): Force output format. Default: inferred from output file extension"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Throws:"})}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Error if input file cannot be read or output file cannot be written"}),"\n",(0,i.jsx)(e.li,{children:"Error if decryption fails"}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Example:"})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-typescript",children:"// Basic usage\nsops.decrypt('secrets.enc.json', 'secrets.yaml');\n\n// Force YAML format regardless of extension\nsops.decrypt('secrets.enc.json', 'secrets.config', {\n  format: 'yaml'\n});\n"})}),"\n",(0,i.jsx)(e.h4,{id:"method-view",children:"Method: view"}),"\n",(0,i.jsx)(e.p,{children:"Reads and decrypts an encrypted file, returning the contents as an object with type safety."}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-typescript",children:"view<T = any>(inputPath: string, options?: OperationOptions): T;\n"})}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Type Parameters:"})}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:"T"})," (default: any): The type of the decrypted content"]}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Parameters:"})}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:"inputPath"})," (string): Path to the encrypted file"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:"options"})," (OperationOptions, optional): View options","\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:"keyPath"})," (string, optional): Override the instance's keyPath for this operation"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Returns:"})}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"(T): The decrypted content as an object of type T"}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Throws:"})}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Error if input file cannot be read"}),"\n",(0,i.jsx)(e.li,{children:"Error if decryption fails"}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Example:"})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-typescript",children:"// Define your secrets structure\ninterface Secrets {\n  data: {\n    api: {\n      key: string;\n      secret: string;\n    };\n  };\n}\n\n// Get typed secrets\nconst secrets = sops.view<Secrets>('secrets.enc.json');\n\n// TypeScript knows this is a string\nconst apiKey = secrets.data.api.key;\n"})}),"\n",(0,i.jsx)(e.h4,{id:"method-get",children:"Method: get"}),"\n",(0,i.jsx)(e.p,{children:"Retrieves a specific value from an encrypted file using a dot-notation path."}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-typescript",children:"get(inputPath: string, dotPath: string, options?: OperationOptions): any;\n"})}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Parameters:"})}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:"inputPath"})," (string): Path to the encrypted file"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:"dotPath"})," (string): Dot-notation path to the value (e.g., 'data.api.key')"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:"options"})," (OperationOptions, optional): Get options","\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:"keyPath"})," (string, optional): Override the instance's keyPath for this operation"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Returns:"})}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"(any): The value at the specified path"}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Throws:"})}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Error if input file cannot be read"}),"\n",(0,i.jsx)(e.li,{children:"Error if decryption fails"}),"\n",(0,i.jsx)(e.li,{children:"Error if path does not exist in the decrypted content"}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Example:"})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-typescript",children:"// Get a specific value\nconst apiKey = sops.get('secrets.enc.json', 'data.api.key');\nconsole.log('API Key:', apiKey);\n\n// Get a nested value\nconst dbPassword = sops.get('secrets.enc.json', 'data.database.password');\n"})}),"\n",(0,i.jsx)(e.h4,{id:"method-rotate",children:"Method: rotate"}),"\n",(0,i.jsx)(e.p,{children:"Re-encrypts an encrypted file with a new initialization vector."}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-typescript",children:"rotate(inputPath: string, outputPath?: string, options?: OperationOptions): void;\n"})}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Parameters:"})}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:"inputPath"})," (string): Path to the encrypted file"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:"outputPath"})," (string, optional): Path where the re-encrypted file will be written. Default: same as inputPath"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:"options"})," (OperationOptions, optional): Rotate options","\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:"keyPath"})," (string, optional): Override the instance's keyPath for this operation"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Throws:"})}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Error if input file cannot be read or output file cannot be written"}),"\n",(0,i.jsx)(e.li,{children:"Error if decryption or re-encryption fails"}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Example:"})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-typescript",children:"// Rotate in place (overwrites the original file)\nsops.rotate('secrets.enc.json');\n\n// Rotate to a new file\nsops.rotate('secrets.enc.json', 'rotated-secrets.enc.json');\n"})}),"\n",(0,i.jsx)(e.h4,{id:"method-encryptcontent",children:"Method: encryptContent"}),"\n",(0,i.jsx)(e.p,{children:"Encrypts a JavaScript object directly without reading from or writing to files."}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-typescript",children:"encryptContent(content: any, options?: OperationOptions): EncryptedContent;\n"})}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Parameters:"})}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:"content"})," (any): The data to encrypt"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:"options"})," (OperationOptions, optional): Encryption options","\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:"keyPath"})," (string, optional): Override the instance's keyPath for this operation"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Returns:"})}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"(EncryptedContent): An object containing the encrypted content and metadata"}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Throws:"})}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Error if encryption fails or key cannot be read"}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Example:"})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-typescript",children:"interface SecretData {\n  api: {\n    key: string;\n  };\n}\n\nconst plainContent: SecretData = {\n  api: {\n    key: 'secret_value'\n  }\n};\n\nconst encrypted = sops.encryptContent(plainContent);\nconsole.log(encrypted);\n"})}),"\n",(0,i.jsx)(e.h4,{id:"method-decryptcontent",children:"Method: decryptContent"}),"\n",(0,i.jsx)(e.p,{children:"Decrypts an encrypted content object directly without reading from or writing to files, with type safety."}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-typescript",children:"decryptContent<T = any>(encryptedContent: EncryptedContent, options?: OperationOptions): T;\n"})}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Type Parameters:"})}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:"T"})," (default: any): The type of the decrypted content"]}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Parameters:"})}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:"encryptedContent"})," (EncryptedContent): The encrypted content object"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:"options"})," (OperationOptions, optional): Decryption options","\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:"keyPath"})," (string, optional): Override the instance's keyPath for this operation"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Returns:"})}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"(T): The decrypted content as an object of type T"}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Throws:"})}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Error if decryption fails or key cannot be read"}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Example:"})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-typescript",children:"// Define the expected structure\ninterface SecretData {\n  api: {\n    key: string;\n  };\n}\n\n// First encrypt some content\nconst plainContent: SecretData = { api: { key: 'secret_value' } };\nconst encrypted = sops.encryptContent(plainContent);\n\n// Later decrypt it with type safety\nconst decrypted = sops.decryptContent<SecretData>(encrypted);\n\n// TypeScript knows this is a string\nconst key = decrypted.api.key;\n"})}),"\n",(0,i.jsx)(e.h2,{id:"error-handling-with-typescript",children:"Error Handling with TypeScript"}),"\n",(0,i.jsx)(e.p,{children:"All methods can throw errors if operations fail. In TypeScript, it's recommended to use try/catch blocks with type narrowing for error handling:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-typescript",children:"try {\n  const secrets = sops.view('secrets.enc.json');\n  // Use the secrets...\n} catch (error) {\n  if (error instanceof Error) {\n    console.error('Failed to read secrets:', error.message);\n  } else {\n    console.error('Unknown error occurred');\n  }\n  // Handle the error appropriately\n}\n"})}),"\n",(0,i.jsx)(e.h2,{id:"advanced-type-examples",children:"Advanced Type Examples"}),"\n",(0,i.jsx)(e.h3,{id:"strong-typing-for-nested-secrets",children:"Strong Typing for Nested Secrets"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-typescript",children:"interface ApiConfig {\n  key: string;\n  secret: string;\n  endpoint: string;\n}\n\ninterface DatabaseConfig {\n  host: string;\n  port: number;\n  username: string;\n  password: string;\n}\n\ninterface AppConfig {\n  environment: 'development' | 'staging' | 'production';\n  api: ApiConfig;\n  database: DatabaseConfig;\n  features: {\n    featureA: boolean;\n    featureB: boolean;\n  };\n}\n\n// Get strongly typed configuration\nconst config = sops.view<AppConfig>('app-config.enc.json');\n\n// TypeScript provides full autocomplete and type checking\nconst apiEndpoint = config.api.endpoint;\nconst isDevelopment = config.environment === 'development';\nconst isFeatureAEnabled = config.features.featureA;\n"})}),"\n",(0,i.jsx)(e.h3,{id:"creating-type-safe-apis-with-node-sops",children:"Creating Type-Safe APIs with Node SOPS"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-typescript",children:"import { Sops } from 'node-sops';\n\n// Define your configuration schema\ninterface Config {\n  database: {\n    host: string;\n    port: number;\n    username: string;\n    password: string;\n  };\n  api: {\n    key: string;\n    timeout: number;\n  };\n}\n\n// Create a strongly typed configuration service\nclass ConfigService {\n  private readonly config: Config;\n  \n  constructor(configPath: string) {\n    const sops = new Sops();\n    this.config = sops.view<Config>(configPath);\n  }\n  \n  getDatabaseConfig(): Config['database'] {\n    return this.config.database;\n  }\n  \n  getApiConfig(): Config['api'] {\n    return this.config.api;\n  }\n  \n  // Type-safe getter for any config property\n  get<K extends keyof Config>(key: K): Config[K] {\n    return this.config[key];\n  }\n}\n\n// Usage\nconst configService = new ConfigService('config.enc.json');\nconst dbConfig = configService.getDatabaseConfig();\nconst apiTimeout = configService.get('api').timeout;\n"})})]})}function p(n={}){const{wrapper:e}={...(0,r.R)(),...n.components};return e?(0,i.jsx)(e,{...n,children:(0,i.jsx)(d,{...n})}):d(n)}},8453:(n,e,t)=>{t.d(e,{R:()=>o,x:()=>c});var s=t(6540);const i={},r=s.createContext(i);function o(n){const e=s.useContext(r);return s.useMemo((function(){return"function"==typeof n?n(e):{...e,...n}}),[e,n])}function c(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(i):n.components||i:o(n.components),s.createElement(r.Provider,{value:e},n.children)}}}]);